(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{481:function(e,t,v){"use strict";v.r(t);var _=v(2),c=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"socket跟tcp-ip-的关系-单台服务器上的并发tcp连接数可以有多少"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#socket跟tcp-ip-的关系-单台服务器上的并发tcp连接数可以有多少"}},[e._v("#")]),e._v(" socket跟TCP/IP 的关系,单台服务器上的并发TCP连接数可以有多少")]),e._v(" "),t("h2",{attrs:{id:"常识一-文件句柄限制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常识一-文件句柄限制"}},[e._v("#")]),e._v(" 常识一：文件句柄限制")]),e._v(" "),t("blockquote",[t("p",[e._v("在linux下编写网络服务器程序的朋友肯定都知道每一个tcp连接都要占一个文件描述符，一旦这个文件描述符使用完了，新的连接到来返回给我们的错误是"),t("code",[e._v("“Socket/File:Can'topen so many files”")]),e._v("。")])]),e._v(" "),t("p",[e._v("这时你需要明白操作系统对可以打开的"),t("strong",[e._v("最大文件数的限制")]),e._v("。")]),e._v(" "),t("ul",[t("li",[e._v("进程限制\n执行ulimit -n 输出1024，说明对于一个进程而言最多只能打开1024个文件，所以你要采用此默认配置最多也就可以并发上千个TCP连接。\n"),t("ul",[t("li",[e._v("临时修改：ulimit -n1000000，但是这种临时修改只对当前登录用户目前的使用环境有效，系统重启或用户退出后就会失效。")]),e._v(" "),t("li",[e._v("永久修改：编辑/etc/security/limits.conf 文件， 修改后内容为")])])])]),e._v(" "),t("div",{staticClass:"language-yml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-yml"}},[t("code",[e._v("    * soft nofile 1000000\n    * hard nofile 1000000\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("ul",[t("li",[e._v("全局限制")])]),e._v(" "),t("p",[e._v("执行 "),t("code",[e._v("cat/proc/sys/fs/file-nr")]),e._v(" 输出9344 0592026，分别为：")]),e._v(" "),t("ol",[t("li",[e._v("已经分配的文件句柄数")]),e._v(" "),t("li",[e._v("已经分配但没有使用的文件句柄数")]),e._v(" "),t("li",[e._v("最大文件句柄数。但在kernel2.6版本中第二项的值总为0，这并不是一个错误，它实际上意味着已经分配的文件描述符无一浪费的都已经被使用了 。")])]),e._v(" "),t("blockquote",[t("p",[e._v("我们可以把这个数值改大些，用 root 权限修改 /etc/sysctl.conf 文件:")])]),e._v(" "),t("div",{staticClass:"language-yml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-yml"}},[t("code",[e._v("fs.file"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("max = 1000000\nnet.ipv4.ip_conntrack_max = 1000000\nnet.ipv4.netfilter.ip_conntrack_max = 1000000\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("h2",{attrs:{id:"常识二-端口号范围限制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常识二-端口号范围限制"}},[e._v("#")]),e._v(" 常识二：端口号范围限制？")]),e._v(" "),t("blockquote",[t("p",[e._v("操作系统上端口号"),t("code",[e._v("1024")]),e._v("以下是系统保留的，从"),t("code",[e._v("1024-65535")]),e._v("是用户使用的。由于每个TCP连接都要占一个端口号，所以我们最多可以有60000多个并发连接。我想有这种错误思路朋友不在少数吧？（其中我过去就一直这么认为）")])]),e._v(" "),t("blockquote",[t("p",[e._v("我们来分析一下吧")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("如何标识一个TCP连接：系统用一个4四元组来唯一标识一个TCP连接："),t("code",[e._v("{local ip, local port,remoteip,remoteport}")]),e._v("。好吧，我们拿出《UNIX网络编程：卷一》第四章中对accept的讲解来看看概念性的东西，第二个参数"),t("code",[e._v("cliaddr")]),e._v("代表了客户端的ip地址和端口号。而我们作为服务端实际只使用了bind时这一个端口，说明端口号"),t("code",[e._v("65535")]),e._v("并不是并发量的限制。")])]),e._v(" "),t("li",[t("p",[e._v("server最大tcp连接数：server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有"),t("code",[e._v("remoteip")]),e._v("（也就是client ip）和"),t("code",[e._v("remoteport")]),e._v("（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。")])])]),e._v(" "),t("p",[e._v("要写网络程序就必须用"),t("code",[e._v("Socket")]),e._v("，这是程序员都知道的。而且，面试的时候，我们也会问对方会不会Socket编程？一般来说，很多人都会说，Socket编程基本就是"),t("code",[e._v("listen")]),e._v("，"),t("code",[e._v("accept")]),e._v("以及"),t("code",[e._v("send")]),e._v("，"),t("code",[e._v("write")]),e._v("等几个基本的操作。是的，就跟常见的文件操作一样，只要写过就一定知道。")]),e._v(" "),t("p",[e._v("对于网络编程，我们也言必称"),t("code",[e._v("TCP/IP")]),e._v("，似乎其它网络协议已经不存在了。对于TCP/IP，我们还知道"),t("code",[e._v("TCP")]),e._v("和"),t("code",[e._v("UDP")]),e._v("，前者可以保证数据的正确和可靠性，后者则允许数据丢失。最后，我们还知道，在建立连接前，必须知道对方的IP地址和端口号。除此，普通的程序员就不会知道太多了，很多时候这些知识已经够用了。最多，写服务程序的时候，会使用多线程来处理并发访问。")]),e._v(" "),t("blockquote",[t("p",[e._v("我们还知道如下几个事实：")])]),e._v(" "),t("ol",[t("li",[t("p",[e._v("一个指定的端口号不能被多个程序共用。比如，如果IIS占用了80端口，那么"),t("code",[e._v("Apache")]),e._v("就不能也用80端口了。")])]),e._v(" "),t("li",[t("p",[e._v("很多防火墙只允许特定目标端口的数据包通过。")])]),e._v(" "),t("li",[t("p",[e._v("服务程序在"),t("code",[e._v("listen")]),e._v("某个端口并"),t("code",[e._v("accept")]),e._v("某个连接请求后，会生成一个新的"),t("code",[e._v("socket")]),e._v("来对该请求进行处理。")])])]),e._v(" "),t("p",[e._v("于是，一个困惑了我很久的问题就产生了。如果一个socket创建后并与80端口绑定后，是否就意味着该socket占用了80端口呢？如果是这样的，那么当其accept一个请求后，生成的新的socket到底使用的是什么端口呢（我一直以为系统会默认给其分配一个空闲的端口号）？如果是一个空闲的端口，那一定不是80端口了，于是以后的TCP数据包的目标端口就不是80了--防火墙一定会组织其通过的！实际上，我们可以看到，防火墙并没有阻止这样的连接，而且这是最常见的连接请求和处理方式。我的不解就是，为什么防火墙没有阻止这样的连接？它是如何判定那条连接是因为connet80端口而生成的？是不是TCP数据包里有什么特别的标志？或者防火墙记住了什么东西？")]),e._v(" "),t("p",[e._v("后来，我又仔细研读了"),t("code",[e._v("TCP/IP")]),e._v("的协议栈的原理，对很多概念有了更深刻的认识。比如，在TCP和UDP同属于传输层，共同架设在IP层（网络层）之上。而IP层主要负责的是在节点之间"),t("code",[e._v("（End to End）")]),e._v("的数据包传送，这里的节点是一台网络设备，比如计算机。因为IP层只负责把数据送到节点，而不能区分上面的不同应用，所以TCP和UDP协议在其基础上加入了端口的信息，端口于是标识的是一个节点上的一个应用。除了增加端口信息，UPD协议基本就没有对IP层的数据进行任何的处理了。而TCP协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口"),t("code",[e._v("（Slice Window）")]),e._v("，以及接收确认和重发机制，以达到数据的可靠传送。不管应用层看到的是怎样一个稳定的TCP数据流，下面传送的都是一个个的IP数据包，需要由TCP协议来进行数据重组。")]),e._v(" "),t("p",[e._v("所以，我有理由怀疑，防火墙并没有足够的信息判断TCP数据包的更多信息，除了IP地址和端口号。而且，我们也看到，所谓的端口，是为了区分不同的应用的，以在不同的IP包来到的时候能够正确转发。")]),e._v(" "),t("p",[t("code",[e._v("TCP/IP")]),e._v("只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。就像操作系统会提供标准的编程接口，比如Win32编程接口一样，TCP/IP也必须对外提供编程接口，这就是Socket编程接口--原来是这么回事啊！")]),e._v(" "),t("p",[e._v("在Socket编程接口里，设计者提出了一个很重要的概念，那就是socket。这个socket跟文件句柄很相似，实际上在BSD系统里就是跟文件句柄一样存放在一样的进程句柄表里。这个socket其实是一个序号，表示其在句柄表中的位置。这一点，我们已经见过很多了，比如文件句柄，窗口句柄等等。这些句柄，其实是代表了系统中的某些特定的对象，用于在各种函数中作为参数传入，以对特定的对象进行操作--这其实是C语言的问题，在C++语言里，这个句柄其实就是this指针，实际就是对象指针啦。")]),e._v(" "),t("p",[e._v("现在我们知道，socket跟TCP/IP并没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以，socket的出现只是可以更方便的使用"),t("code",[e._v("TCP/IP")]),e._v("协议栈而已，其对TCP/IP进行了抽象，形成了几个最基本的函数接口。比如"),t("code",[e._v("create")]),e._v("，"),t("code",[e._v("listen")]),e._v("，"),t("code",[e._v("accept")]),e._v("，"),t("code",[e._v("connect")]),e._v("，"),t("code",[e._v("read")]),e._v("和"),t("code",[e._v("write")]),e._v("等等。")]),e._v(" "),t("p",[e._v("现在我们明白，如果一个程序创建了一个"),t("code",[e._v("socket")]),e._v("，并让其监听80端口，其实是向"),t("code",[e._v("TCP/IP")]),e._v("协议栈声明了其对80端口的占有。以后，所有目标是80端口的TCP数据包都会转发给该程序（这里的程序，因为使用的是Socket编程接口，所以首先由Socket层来处理）。所谓accept函数，其实抽象的是TCP的连接建立过程。accept函数返回的新socket其实指代的是本次创建的连接，而一个连接是包括两部分信息的，一个是源IP和源端口，另一个是宿IP和宿端口。所以，accept可以产生多个不同的socket，而这些socket里包含的宿IP和宿端口是不变的，变化的只是源IP和源端口。这样的话，这些socket宿端口就可以都是80，而Socket层还是能根据源/宿对来准确地分辨出IP包和socket的归属关系，从而完成对TCP/IP协议的操作封装！而同时，放火墙的对IP包的处理规则也是清晰明了，不存在前面设想的种种复杂的情形。")]),e._v(" "),t("p",[e._v("原文地址：https://blog.csdn.net/huangjin0507/article/details/52396621")])])}),[],!1,null,null,null);t.default=c.exports}}]);