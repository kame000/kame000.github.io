(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{559:function(s,a,n){"use strict";n.r(a);var e=n(2),t=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"nginx负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx负载均衡"}},[s._v("#")]),s._v(" Nginx负载均衡")]),s._v(" "),a("blockquote",[a("p",[s._v("nginx不单可以作为强大的web服务器，也可以作为一个反向代理服务器，而且nginx还可以按照调度规则实现动态、静态页面的分离，可以按照轮询、ip哈希、URL哈希、权重等多种方式对后端服务器做负载均衡，同时还支持后端服务器的健康检查。")])]),s._v(" "),a("h2",{attrs:{id:"nginx负载均衡一些基础知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx负载均衡一些基础知识"}},[s._v("#")]),s._v(" Nginx负载均衡一些基础知识:")]),s._v(" "),a("h3",{attrs:{id:"nginx-的-upstream目前支持-4-种方式的分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx-的-upstream目前支持-4-种方式的分配"}},[s._v("#")]),s._v(" nginx 的 upstream目前支持 4 种方式的分配")]),s._v(" "),a("ul",[a("li",[s._v("轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。")]),s._v(" "),a("li",[s._v("weight\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。")]),s._v(" "),a("li",[s._v("ip_hash\n每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。")]),s._v(" "),a("li",[s._v("fair（第三方）\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。")]),s._v(" "),a("li",[s._v("url_hash（第三方）")])]),s._v(" "),a("h2",{attrs:{id:"配置使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置使用"}},[s._v("#")]),s._v(" 配置使用")]),s._v(" "),a("h3",{attrs:{id:"在http节点里添加"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在http节点里添加"}},[s._v("#")]),s._v(" 在http节点里添加:")]),s._v(" "),a("div",{staticClass:"language-yml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-yml"}},[a("code",[s._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#定义负载均衡设备的 Ip及设备状态")]),s._v("\n    upstream myServer "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("   \n\n        server 127.0.0.1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("9090 down;\n        server 127.0.0.1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("8080 weight=2;\n        server 127.0.0.1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("6060;\n        server 127.0.0.1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("7070 backup;\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("blockquote",[a("p",[s._v("在需要使用负载的Server节点下添加")])]),s._v(" "),a("p",[a("code",[s._v("proxy_pass http://myServer;")])]),s._v(" "),a("h2",{attrs:{id:"upstream-每个设备的状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#upstream-每个设备的状态"}},[s._v("#")]),s._v(" upstream 每个设备的状态:")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("down")]),s._v(" 表示单前的server暂时不参与负载")]),s._v(" "),a("li",[a("code",[s._v("weight")]),s._v("  默认为1.weight越大，负载的权重就越大。")]),s._v(" "),a("li",[a("code",[s._v("max_fails")]),s._v("：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误")]),s._v(" "),a("li",[a("code",[s._v("fail_timeout")]),s._v(": max_fails 次失败后，暂停的时间。")]),s._v(" "),a("li",[a("code",[s._v("backup")]),s._v("： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。")])]),s._v(" "),a("p",[s._v("Nginx还支持多组的负载均衡,可以配置多个upstream  来服务于不同的Server.")]),s._v(" "),a("p",[s._v("配置负载均衡比较简单,但是最关键的一个问题是怎么实现多台服务器之间"),a("code",[s._v("session")]),s._v("的共享")]),s._v(" "),a("h2",{attrs:{id:"配置方法介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置方法介绍"}},[s._v("#")]),s._v(" 配置方法介绍")]),s._v(" "),a("ul",[a("li",[s._v("不使用session，换作cookie")])]),s._v(" "),a("p",[s._v("能把session改成cookie，就能避开session的一些弊端，在从前看的一本J2EE的书上，也指明在集群系统中不能用session，否则惹出祸端来就不好办。如果系统不复杂，就优先考虑能否将session去掉，改动起来非常麻烦的话，再用下面的办法。")]),s._v(" "),a("ul",[a("li",[s._v("应用服务器自行实现共享")])]),s._v(" "),a("p",[s._v("asp.net可以用数据库或memcached来保存session，从而在asp.net本身建立了一个session集群，用这样的方式可以令 session保证稳定，即使某个节点有故障，session也不会丢失，适用于较为严格但请求量不高的场合。但是它的效率是不会很高的，不适用于对效率 要求高的场合。")]),s._v(" "),a("p",[s._v("以上两个办法都跟nginx没什么关系，下面来说说用nginx该如何处理：")]),s._v(" "),a("ul",[a("li",[s._v("ip_hash")])]),s._v(" "),a("p",[s._v("nginx中的ip_hash技术能够将某个ip的请求定向到同一台后端，这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip_hash是在upstream配置中定义的：")]),s._v(" "),a("div",{staticClass:"language-yml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-yml"}},[a("code",[s._v("    upstream backend "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n      server 127.0.0.1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("8080 ;\n      server 127.0.0.1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("9090 ;\n       ip_hash;\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h3",{attrs:{id:"ip-hash是容易理解的-但是因为仅仅能用ip这个因子来分配后端-因此ip-hash是有缺陷的-不能在一些情况下使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ip-hash是容易理解的-但是因为仅仅能用ip这个因子来分配后端-因此ip-hash是有缺陷的-不能在一些情况下使用"}},[s._v("#")]),s._v(" ip_hash是容易理解的，但是因为仅仅能用ip这个因子来分配后端，因此ip_hash是有缺陷的，不能在一些情况下使用：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。")])]),s._v(" "),a("li",[a("p",[s._v("nginx的后端还有其它方式的负载均衡。假如nginx后端又有其它负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台session应用服务器上。这么算起来，nginx后端只能直接指向应用服务器，或者再搭一个squid，然后指向应用服务器。最好的办法是用location作一次分流，将需要session的部分请求通过ip_hash分流，剩下的走其它后端去。")])]),s._v(" "),a("li",[a("p",[s._v("upstream_hash")])])]),s._v(" "),a("p",[s._v("为了解决ip_hash的一些问题，可以使用upstream_hash这个第三方模块，这个模块多数情况下是用作url_hash的，但是并不妨碍将它用来做session共享：")]),s._v(" "),a("p",[s._v("假如前端是squid，他会将ip加入x_forwarded_for这个http_header里，用upstream_hash可以用这个头做因子，将请求定向到指定的后端：")]),s._v(" "),a("p",[s._v("可见这篇文档：http://www.sudone.com/nginx/nginx_url_hash.html")]),s._v(" "),a("p",[s._v("在文档中是使用"),a("code",[s._v("$request_uri")]),s._v("做因子，稍微改一下：")]),s._v(" "),a("p",[a("code",[s._v("hash $http_x_forwarded_for;")])]),s._v(" "),a("p",[s._v("这样就改成了利用"),a("code",[s._v("x_forwarded_for")]),s._v("这个头作因子，在nginx新版本中可支持读取cookie值，所以也可以改成：")]),s._v(" "),a("p",[a("code",[s._v("hash $cookie_jsessionid;")])]),s._v(" "),a("p",[s._v("假如在php中配置的session为无cookie方式，配合nginx自己的一个userid_module模块就可以用nginx自发一个cookie，可参见userid模块的英文文档：")])])}),[],!1,null,null,null);a.default=t.exports}}]);