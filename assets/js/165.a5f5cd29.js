(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{569:function(t,a,r){"use strict";r.r(a);var i=r(2),s=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"rabbitmq的一些基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq的一些基本概念"}},[t._v("#")]),t._v(" RabbitMQ的一些基本概念")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("MQ 全称为 Message Queue，消息队列（MQ）是一种应用程序对应用程序的通信方法，即我们常说的中间件之一，而 RabbitMQ 则是 MQ 的一种开源实现，遵循 AMQP（高级消息队列协议） 协议。")]),t._v(" "),a("h2",{attrs:{id:"amqp-相关概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#amqp-相关概念"}},[t._v("#")]),t._v(" AMQP 相关概念")]),t._v(" "),a("p",[t._v("MQ 的模型从大体上看，都是类似的，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://img.liuwenqi.com/blog/2019-07-19-165232.png",alt:"mq"}})]),t._v(" "),a("p",[t._v("而 RabbitMQ 由于是基于 AMQP 协议的开源实现，AMQP 协议比 MQ 模型有更加详细的模型概念，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://img.liuwenqi.com/blog/2019-07-19-165244.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"信道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信道"}},[t._v("#")]),t._v(" 信道")]),t._v(" "),a("p",[t._v("如果项目需要发布消息，那么必须要链接到 RabbitMQ，而项目于 RabbitMQ之间使用 TCP 连接，加入每次发布消息都要连接TCP，这不仅会造成连接资源严重浪费，会造成服务器性能瓶颈，所以 RabbitMQ 为所有的线程只用一条 TCP 连接，怎么实现的呢？RabbitMQ 引入了信道的概念，所有需要发布消息的线程都包装成一条信道在 TCP 中传输，理论上 一条 TCP 连接支持无限多个信道，模型如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://img.liuwenqi.com/blog/2019-07-19-171216.png",alt:"mq"}})]),t._v(" "),a("h3",{attrs:{id:"队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),a("p",[t._v("消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。")]),t._v(" "),a("h3",{attrs:{id:"绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绑定"}},[t._v("#")]),t._v(" 绑定")]),t._v(" "),a("p",[t._v("绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表，如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://img.liuwenqi.com/blog/2019-07-19-190435.jpg",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"交换器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#交换器"}},[t._v("#")]),t._v(" 交换器")]),t._v(" "),a("p",[t._v("我们向 RabbitMQ 发送消息，实际上是把消息发到交换器了，再由交换器根据相关路由规则发到特定队列上，在队列上监听的消费者就可以进行消费了，目前 RabbitMQ 共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：")]),t._v(" "),a("h4",{attrs:{id:"direct交换器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#direct交换器"}},[t._v("#")]),t._v(" direct交换器")]),t._v(" "),a("p",[t._v("消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://img.liuwenqi.com/blog/2019-07-19-190459.jpg",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"fanout交换器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fanout交换器"}},[t._v("#")]),t._v(" fanout交换器")]),t._v(" "),a("p",[t._v("每个发送到 fanout 交换器中的消息，他不会去匹配路由键，直接把消息投递到所有绑定到 fanout 交换器中的队列上，它就像一个广播站一样，它会向所有收听广播的用户发送消息。对应到系统上，它允许你针对一个消息作不同操作，比如用户上传了一张新的图片，系统要同时对这个事件进行不同的操作，比如删除旧的图片缓存、增加积分奖励等等。这样就大大降低了系统之间的耦合度了。")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://img.liuwenqi.com/blog/2019-07-19-190522.jpg",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"topic交换器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#topic交换器"}},[t._v("#")]),t._v(" topic交换器")]),t._v(" "),a("p",[t._v("topic 交换器有点类似于 direct 交换器，它通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“*”。#匹配0个或多个单词，*匹配不多不少一个单词。")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://img.liuwenqi.com/blog/2019-07-19-190543.jpg",alt:""}})])])}),[],!1,null,null,null);a.default=s.exports}}]);